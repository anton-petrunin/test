ОПРЕДЕЛЕНИЕ БОЛЬШИНСТВА (IDENTIFYING THE MAJORITY)


Идея состоит в том, что каждый раз, когда на счётчике появляется 0 (начальная позиция), 
вы запоминаете имя, которое слышите в данный момент, и добавляете на счётчике 1. Когда на счётчике больше, чем 0, вы прибавляете, если имя, которое вы слышите  то же, что вы держите в уме.  В противном случае отнимаете на счётчике 1, но сохраняете в уме прежнее имя.
    Возможно, конечно, закончить с именем, которое называлось только один раз (например, если список был “Aлиса, Боб, Алиса, Боб, Алиса, Боб, Чарли”).  Тем не менее, если имя появлялось больше, чем половина раз, то оно гарантированно сохранится у вас в уме до конца. Причина того, что имя останется в вашей памяти, состоит в том, что на счётчике больше прибавляется, чем отнимается.


  Данный алгоритм описан в статье Майкла Фишера и Стивена Зальцберга в журнале “Aлгоритмы”, Декабрь 1989 г. (M. J. Fischer and S.L.Salzberg, “Finding a Majority Among n Votes” Journal of Algorithms Vol. 3, No 4 (December 1989), pp 362-380)


ОБЕЗДВИЖИВАТЕЛЬ КОНВЕЯ (THE CONWAY IMMOBILIZER)


 Непросто придумать алгоритм, который успешно продвигается вперёд, избегает зацикливания и не делает никаких глупостей, когда вы уже практически дошли до цели.
В данной задаче сработает следующий трюк. 
     Перекладываете карту направо (по кругу, если понадобится) на пустую колоду, если такая имеется,  кроме случаев  K, -- , Т или К, Т, -- , при которых нужно положить туза на короля. Если открыты все карты и дама находится в левой колоде, кладёте на даму короля, в противном случае,  карту справа от дамы перекладываете на одну колоду вправо (опять же, можно при необходимости двигаться по кругу).
   Очевидно, что нет хода, который собирает три карты в стопку, если только изначально не была выигрышная комбинация. Комбинация два -- один, даже такая, как К, -- , Т или
К, Т, -- ,  откроет все карты максимально за три хода (если игра еще не выиграна). Таким образом, достаточно проверить (смотрите прилагаемую диаграмму), что все шесть возможных комбинаций открытых карт приводят к победе.


   Удивительным образом, этот алгоритм можно обобщить для работы с любым количеством карт (фиксированным, известным), оперируя всё теми же тремя колодами.
Скажем, для  52 карт, пронумерованных от 1 до 52, следующие правила (данные в приоритетном порядке) в конечном итоге приведут к тому, что слева окажется колода, сложенная по-порядку с 1 наверху.  
Итак, если вы видите:
  
1.  2, 1, -- , кладёте 1 на 2.


2. две произвольные карты, -- перекладываете карту направо (по кругу, если необходимо) на пустую колоду.
3. k, j, k-1, где j < k, -- кладёте  k-1 на k
4. только одну карту, -- перекладываете карту налево.
5. три карты, -- карту справа от наибольшей перекладываете направо.


  Докажем, что этот алгоритм действительно работает. Предположим, что карта 52 открыта и лежит на средней или на правой колоде. Тогда, следуя правилу (2) и (5), она в итоге окажется в левой колоде вместе со всеми остальными картами из средней колоды.  По мере их перемещения вправо согласно правилу (2), карты 51, 50, 49, …, k будут складываться на 52 согласно правилу (3) для некоторых k < 52, и средняя колода опустеет. Разумеется, если k = 1, мы решили задачу, правило (1) сделало последний ход.
В противном случае карта k переместится в среднюю колоду по правилу (2) и в правую по правилу (5), за ней аналогичным образом последует карта k+1, и так далее, пока в правой колоде не окажется 51 карта, сложенные по-порядку, с картой 51 внизу и картой k наверху.
   Теперь карта 52 кладётся на среднюю колоду, а правая колода перекладывается в обратном порядке на левую колоду, карта 52 передвигается на правую колоду, левая колода перемещается на среднюю колоду, снова меняя порядок, и карта 52 перекладывается обратно на левую колоду. В этот момент в средней колоде окажутся карты от 51 до k, с 51 наверху. Дальше карты с 51 до k перемещаются согласно правилу (2) направо и оказываются в левой колоде по правилу (3), до тех пор пока, опять, k, k+1, …, 52 не попадут в левую колоду.
    Правая колода сейчас пустая, следовательно, карта k-1 находится где-то в средней колоде. Если она не в самом низу, она перейдёт в левую колоду и процесс, описанный выше, повторится для k’ < k.  Если случилось так, что она оказалась в самом низу колоды, она не попадёт влево (если только, это не карта 1), потому что, когда она переместится вправо по правилу (5), средняя колода окажется пустой, и мы вынуждены применить правило (2) вместо (3). Однако, в конце следующего цикла, в средней колоде будет обратный порядок, с картой k-1 наверху. Отсюда следует, что хотя бы каждый второй раз, когда карта 52 снова кладётся на пустую левую колоду, порядок k уменьшается.
   Мы сможем завершить доказательство, если покажем, что предполагаемое выше условие, что карта 52 находится на верху средней или правой колоды, должно когда-нибудь случиться. Предположим вначале, что карта 52 лежит на верху левой колоды (все остальные карты под ней). Тогда она может собрать карты 51, 50, …, k над собой, следуя правилу (3), а  остальные карты окажутся в средней и, возможно, в правой колоде.
Затем правила (2) и (5) опустошат среднюю колоду. Карта k переместится в середину и потом вправо, затем, аналогично, карта k+1, и так далее (как и выше), пока карта 52 снова не окажется наверху, но на этот раз (после того, как карта 51 перешла на правую колоду) средняя колода будет пустая. Карта 52 кладётся тогда на среднюю колоду, и мы получаем желаемое условие.
                                
                                    Рис стр 107.
КРУТЯЩИЕСЯ ВЫКЛЮЧАТЕЛИ (SPINNING SWITCHERS)


  Эта задача попала ко мне от Саши Барга из Мэрилендского университета, но, похоже, она была уже довольно известна. Как и во многих задачах, здесь будет полезно рассмотреть вначале  более простую версию. Возьмём вариант с двумя выключателями: нажав на обе кнопки, мы выясним, находились ли они в одинаковом состоянии, если да, то лампочка загорится (если она уже не горела).
В противном случае, на следующем шаге нажмём одну кнопку, после этого кнопки будут в одинаковом состоянии, и в наихудшем случае нам придётся сделать ещё один шаг, нажав обе кнопки, чтобы лампочка зажглась.
  
  Вернёмся к варианту с четырьмя лампочками. Обозначим через А операцию, когда мы нажимаем все четыре кнопки, D -- диагональные кнопки, N -- соседние и 
S -- одну кнопку. Тогда последовательность операций ADANASADAND включит лампочку не более, чем за 12 шагов.
  В более общем виде для выключателей в углах - угольника это можно   сделать за шагов следующим образом. Пусть  -- шаги для . Составим из противоположных  выключателей  пары, если -- шаг у -угольника, при котором нажимаются кнопки j , тогда пусть будет шагом у - угольника, при котором нажимаются кнопки  j  и . И тогда  представляет собой последовательность шагов .
  Нам также необходим шаг  для - угольника, при котором нажимаются только кнопки .
  Будем говорить про противополжную пару, что она “чётная”, если оба выключателя включены или выключены. Если все пары чётные, тогда применение шага X’ включит все выключатели. Идея состоит в том, чтобы посредством применения  шагов и т.д.,  сделать все пары чётными, каждый раз проверяя при помощи , добились  ли мы успеха. Порядок шагов :
 
;  ; ; ;
; … ;; 


Или, более компактно: . Всё это --
шагов. Следовательно, если  число шагов, предпринятых для решения -угольника,  и
, итак, это проверено.
  Эта последовательность действий работает, потому что шаги работают на чётных -- нечётных  парах также, как и шаги на включенных -- выключенных парах, и, между тем, шаги абсолютно не влияют на конфигурацию чётных - нечётных пар.


  С другой стороны, задача не имеет решения, если  не является степенью двойки, например, если , где  - нечётное. Для представления  одновременно конфигурации выключателей ( 1 = “включен”, 0 = “выключен”) и операции (1 = “нажать”, 0 = “не трогать”) можно прибегнуть к бинарным векторам длины . Пусть -- такой вектор, и пусть  является результатом вращения на шагов вправо. Применение операции  к конфигурации  приведёт к конфигурации , если нет вращения, но так как оно имеется, мы получаем  для некоторого значения .
  Будем говорить, что n-вектор  является “неровным” [rough ?], если мощность [size?] множества его вращений  не равна степени двойки.
Предположим (как и в начале), что любая неровная конфигурация возможна при некотором вращении. Далее мы утверждаем, что после любой фиксированной операции любая неровная конфигурация все ещё возможна при некоторых вращениях. Таким образом невозможно избавиться от какой-либо неровной конфигурации и, в частности, нельзя гарантировать получения 11 … 1.
   Для нечётного , т.е. , все векторы, кроме 00 … 0 и 11 … 1 являются неровными. Если -- некий вектор и   -- неровный вектор, то либо   ( то же и для ), либо будут неровными, так что, если у одного из векторов до применения  операции было вращение, то вращение теперь должно быть у вектора 
   Если  ,  где , можно разбить n-цикл на сегментов длины  и  будет неровным до тех пор, пока он не одинаковый на всех сегментах. Следовательно, если он неровный, то существует некое такое, что координаты    для   не все равны.  И теперь, применив рассуждение как и выше, просто смотрим на эти координаты.






 КОМНАТА С ОДНОЙ ЛАМПОЧКОЙ (THE ONE-BULB ROOM)


   Я услышал эту задачу от Адама Чэлкрафта (Adam Chalcraft), который имеет честь представлять Великобританию на международных соревнованиях по одноколёсному хоккею. Задача также появлялась на сайте www.ibm.com и была перепечатана в Emissary, информационном бюллетене Математического института (Matematical Science Research Institute) в Беркли. Одна из версий задачи появлялась даже в заслуженно известной программе Национального Общественного радио “Car Talk” в 2003 году.
   Однако, считаю нужным предупредить читателя, что эту задачу иногда  путают с куда более сложной задачей, с которой вам предстоит встретиться в следующей главе.


   Безусловно, необходимо предположить, что между посещениями заключённых никто в комнате  лампочкой не балуется. Заключённым необязательно знать, в каком состоянии изначально находится лампочка. Идея заключается в том, что один из заключённых (скажем, Алиса) всё время пытается лампочку включить, а  каждый из остальных выключает её два раза. 
   То есть, более подробно,  Алиса всегда включает лампочку, если она выключена, в противном случае, оставляет её включённой. Остальные заключённые выключают её первые два раза, если она включена, и оставляют её гореть при последующих посещениях.
   Алиса считает, сколько раз она попадает в тёмную комнату после своего первого 
посещения, после  тёмных визитов, она может заключить, что все побывали в комнате. Почему? Каждое тёмное посещение говорит о том,  что один из заключённых побывал в комнате. Если же кто-то из них, скажем, Боб, не посещал комнаты, тогда лампочка не могла быть выключена больше, чем  раз.  С другой стороны, Алиса в конце концов должна будет достичь её  тёмных визитов, потому что в итоге лампочка будет выключена 
 раз и только одно из этих выключений (если один из заключённых побывал в комнате до первого визита Алисы и выключил изначально горящую лампочку) может не засчитаться Алисой за тёмный визит.
   Если заключённых только два, ясно, что каждый из них узнаёт о том, побывал ли другой в комнате, поскольку Алиса дожидается её первого тёмного повторного посещения, в то время как Боб ждёт свой первый светлый повторный визит.
Однако,  для  заключённых  имеется доказательство того, что невозможно гарантировать, что больше, чем один заключённый сможет сказать, посетили ли все остальные  комнату.  Ниже приводится набросок доказательства. Читателям рекомендуется его пропустить, если только они специально не заинтересованы в том, как получаются отрицательные  результаты в (communications) задачах подобного сорта. Я включил это доказательство потому, что, насколько мне известно, оно нигде не появлялось.
    В основном, мы утверждаем, что противник (который, предполагается, 
 знает стратегию заключённых, составляя расписание посещений)  может вынуждать их совершать бесполезные действия, отличающиеся от тех, что применялись в протоколе выше.
   Давайте сосредоточимся на одном заключённом, Алисе. Предположим, что её стратегия детерминистическая и основана исключительно на последовательности состояний лампочки, которые она до сих пор наблюдала.
  Положим, что стратегия Алисы заставляет её (в некоторых обстоятельствах) изменить состояние (лампочки), после того, как она нашла её в том же состоянии,что и во время своего последнего посещения. Тогда  противник может немедленно отправить её обратно в комнату, “сводя на нет” её предыдущий визит.
В результате, эта часть стратегии Алисы может только дать противнику дополнительную опцию. Исходя из этого, можно предположить, что Алиса не должна менять состояние лампочки, если она находит её в том же виде, что и в свой последний визит.
   Далее, предположим, что Алисе в некий момент требуется оставить лампочку в том же состоянии, в котором она её нашла. Тогда мы утверждаем, что можно предположить, что после этого она никогда снова не предпримет  каких-либо действий! Почему?  Потому что, если противник не хочет, чтобы она продолжала действовать, он может устроить так, что Алиса никогда не увидит лампочку в состоянии, отличном от того, которое она видит в данный момент. Он может это сделать, поскольку, если Алиса действительно останется навсегда неактивной, то, по крайней мере, одно из состояний (“включено” или “выключено”)  будет повторяться бесконечно часто. Положим, это “выключено”. Тогда противник может составить расписание для  Алисы так, что лампочка будет выключена как в её посещении сейчас, так и во всех последующих, и следовательно, согласно предыдущему рассуждению, она никогда не будет снова действовать. Итак, eщё раз, у противника всегда есть возможность заставить  Алису замолчать, и можно предположить, что это его единственная возможность.
   Очевидно, Алиса не может начинать с инструкции оставить лампочку в том же состоянии, как она её находит, так как в этом случае она перестанет действовать совсем, и никто никогда не узнает, посещала ли она комнату. *


[ * Если только она не пользуется очень сильными духами ]


Скажем, она должна включить лампочку, если она выключена, в обратном случае оставить лампочку как есть. Тогда она ничего не будет делать до тех пор, пока опять не попадёт в комнату с выключенной лампочкой, и в этом случае она может только снова включить лампочку или остаться бездейственной навсегда. Таким образом, число раз, когда Алиса включает лампочку, ограничено ( которое может быть константой, иначе у противника будет больше преимуществ). Назовём эту стратегию , где  -- положительное целое число или бесконечность. Аналогичное рассуждение, применённое для случая, когда Алиса должна во время первого визита выключить лампочку, приводит к стратегии 
   Остаётся только один возможный вариант, когда Алиса должна будет изменить состояние лампочки в свой первый визит в комнату, но в этом случае  далее она вынуждена будет продолжить действовать так, как  описано выше, в зависимости от того, включила она лампочку или выключила. И это снова даёт противнику дополнительное преимущество.
   Это сводится к тому, что у каждого заключённого имеется стратегия  или  для различных . Если все они только выключают (или включают) лампочку, никто ничего не сможет определить. Таким образом, можно предположить, что у Алисы стратегия , а у Боба  Если Чарли включает лампочку, Алиса никогда не сможет определить, был ли это последний визит Боба или Чарли, и у Боба и Чарли остаётся ещё по одному заданию. Если Чарли выключает лампочку, то тогда  Боб -- это тот, кому достанется “тёмный визит”.
   Учитывая всё вышесказанное, мы получаем, что для того, чтобы какой-то заключённый смог определить, что все посетили комнату, Алиса должна включить лампочку, в то время как все остальные её выключают (или наоборот). Действительно, если  у Алисы стратегия  а у других стратегии  тогда легко проверить, что условие, при котором конечны  и хотя бы больше 2-х, а больше, чем сумма остальных  минус наименьший из них, является необходимым и достаточным.
  Отсюда следует, что если , тогда максимум одному заключённому гарантирована честь знать, все ли побывали в комнате.
  Уфф!




ДВА ШЕРИФА (ТHE TWO SHERIFFS)


   Если два шерифа (назовём их Лев и Ральф) обмениваются секретной информацией, они могут использовать этот секрет для того, чтобы зашифровать свой разговор и достичь цели. Но так как они никогда прежде не встречались, им нужно будет, на самом деле, изготовить этот свой собственный секрет.
  Будем всегда предполагать, что пары, к которым Лев и Ральф сузили свои списки подозреваемых, не одинаковы, то есть существует возможность определить убийцу. Заметим, что,  если, скажем, Лев просто называет свою пару, тогда Ральф будет знать, кто убийца. Но тогда и банда линчевателей будет знать всё, что знает Лев, так что любая попытка Ральфа сообщить Льву имя убийцы, без того, чтобы об этом не прознали линчеватели, обречена на провал.
  Очевидно, Лев и Ральф должны подойти к определению имени убийцы более хитрым способом. Составим таблицу из всех  возможных пар подозреваемых таким образом, что каждый столбец содержит разбиение восьми подозреваемых на четыре пары. Вот один из способов:
     
                       Таблица стр 112




  Лев и Ральф совершенно свободно могут обсуждать по телефону вопрос о сокрытии информации от линчевателей. В частности, ничто не  может помешать им согласиться пронумеровать подозреваемых и составить такую таблицу, как приведённая выше.
  Дальше Лев сообщает Ральфу, в каком столбце находится его пара. Например, если пара Льва {1,2}, он говорит: “Моя пара в первом столбце.” 
  Если пара Ральфа находится в том же столбце, он тут же понимает, что у него и Льва одинаковые пары. Он может прямо сказать об этом,  после чего шерифам остаётся только повесить трубки и и вернуться к сыскной работе.
  В другом случае Ральф понимает, что пара Льва одна из двух пар в столбце. Вернёмся к нашему примеру, если пара Ральфа {2,3}, он знает, что у Льва должна быть пара  {1,2} или {3,4}. Затем он разделяет столбец на две равные части, так, чтобы обе предполагаемые пары были в одной части, и сообщает об этом разбиении Льву.
   В нашем примере он должен будет сказать Льву: “Моя пара либо в {1,2,3,4}, либо в {5,6,7,8}.” (Если же пара Ральфа была бы {2,5}, он сказал бы: “Моя пара либо в {1,2,4,5}, либо в {3,4,7,8}.” )
   Лев, безусловно, будет знать, в какой части надо искать пару Ральфа, так как она может быть только в той части, где находится его собственная пара. Это теперь тайна Ральфа и Льва!
  Теперь Лев может сказать Ральфу стоит ли его пара на первом или втором месте в соответствующей части. Если, как в примере выше, пары {1,2} и {2,3}, Лев может сказать: “Моя пара первая.”, или, тоже самое, “Моя пара либо {1,2}, либо {5,6}.”
  Далее, Ральфу становится ясно, какая пара у Льва, а, следовательно, и кто является убийцей. Он может сообщить об этом Льву, просто сказав, что убийце в  соответствует большее или меньшее число в паре Льва. То есть, он сказал бы: “Убийца -- самый старший в твоей паре.” , или же: “Убийца -- 2 или 6.”
  Банда линчевателей не сможет понять, о какой из “частей” говорят Лев и Ральф.
Если бы у Льва была пара {5,6}, а у Ральфа {6,7} или {6,8}, то весь разговор, подслушанный линчевателями, был бы абсолютно таким же, как в рассмотренном примере, и в этом случае убийцей оказался бы номер 6 вместо 2.


   Задача о двух шерифах впервые появилась в статье Дональда Бивера, Стюарта Хабера и Питера Винклера в 1996 году [D. Beaver, S. Haber, and P. Winkler “On the Isolation of a Common Secret”, from The Mathematics of Paul Erdos Vol. II, R. L. Gracham and J.Nesetril, editors, Springer-Verlag, Berlin, 1996] Задача была придумана как пример открытия, сделанного вашим автором где-то лет двадцать пять тому назад: а именно --  по открытым каналам связи из общеизвестной информации можно сделать общую тайну. Первоначально эта идея применялась для игры в Бридж, где партнёрам не разрешается иметь предварительные договорённости о значениях заявок и игре. С 1924 года, когда был создан современный Бридж, считалось (неверно), что это правило препятствует какому-либо секретному общению между партнёрами. Это заблуждение оказало весьма сдерживающий эффект на развитие более совершенных методов торговли и стратегии вистующих, так как многие считали, что такие методы могут давать противникам слишком много информации. Например, основанная на научных методах шлемовая торговля подскажет противнику, как вести игру.
   Однако карты у вас в руке (которые, как вы знаете, не должны находиться у вашего партнера) дают вам и вашему партнёру некое общее знание, которое  может быть использовано для секретного общения. Подробную информацию и ссылки можно найти в работе П. Винклера 1983 года. [ P.Winkler “The Advent of Cryptology in the Game of Bridge”, Cryptologia Vol.7 \#4 (October 1983), pp 327-332]




РАССЕЯННЫЙ ПРОФЕССОР (THE ABSENT-MINDED PILL TAKER)


  Профессорская коробочка для таблеток (см. Рис. ниже) состоит из семи прозрачных ячеек, помеченных ВС, ПН, ВТ, СР, ЧТ, ПТ, СБ.  В качестве примера, предположим, что профессор получает 30 новых таблеток в пятницу утром. Он хочет распределить их по ячейкам таким образом, чтобы посмотрев на свою коробочку, начиная с этого дня, он мог бы сказать, выпил он свою ежедневную таблетку, и, если нет, мог бы взять её из соответствующей ячейки.
  Очевидный способ это сделать -- положить по 5 таблеток в ПТ и СБ и по 4 таблетки в ВС, ПН, ВТ, СР и ЧТ.  У него следующий алгоритм:
     Когда коробочка для таблеток содержит непрерывную (mod 7) строку ячеек с k таблетками, а остаток только с k-1,  он знает, что самая левая “тяжёлая” ячейка (с k таблетками) -- это то, откуда нужно взять следующую таблетку. Если это среда, и такая ячейка помечена СР, он берёт оттуда таблетку, если же эта ячейка ЧТ, он знает, что уже таблетку принял.


  Трудность заключается в том, что каждые семь дней все ячейки становятся равными, то есть, в каждой из них одно и тоже число таблеток. Какую ячейку нужно тогда выбрать?
Ну, в данном случае, профессор понимает, что это случится в воскресенье, так что он устанавливает правило: когда ячейки равны, ВС -- контрольный контейнер. То есть, если он видит равные ячейки и этот день -- воскресенье, он берёт таблетку из ВС, если же это суббота, значит, он уже таблетку принял.
  Всё идёт прекрасно до тех пор, пока, 30 дней спустя, он получает новые 30 таблеток.  И теперь это -- воскресенье, значит, когда он распределит таблетки по 5 штук в СБ и ПН и по 4 штуки в остальные ячейки, он видит, что ячейки у него станут равными во вторник утром, а не утром в воскресенье. И это -- катастрофа, профессор не в состоянии будет запомнить, что теперь ВТ -- контрольный контейнер, а не ВС.
  Определённо, существует решение этой задачи, которое не вынуждает вас оставлять таблетки в банке (или выбрасывать их). Но какое? Профессору нужен надёжный способ отмечать ячейку, из которой нужно взять следующую таблетку.  Он мог бы положить значительно большое количество таблеток в одну ячейку и затем передвигать эту “кучу” каждый день, но тогда он не может быть уверенным, что будет помнить, переложил ли он кучу. Так или иначе профессор должен придумать алгоритм, который позволит ему просто принимать свою ежедневную таблетку, не перекладывая остальные. 
    Разумеется, профессор начинает задаваться вопросом, а существует ли решение у этой задачи. Не может ли он доказать невозможность решения? Если каждый день он только берёт одну таблетку из ячейки, помеченной этим днём, тогда, пойдя в обратную сторону от последней таблетки, мы видим, что каждый день коробочка состоит либо из равных ячеек, либо из непрерывной строки ячеек  с k таблетками и остатка ячеек  с k-1 таблетками. Таким образом, он приходит назад к начальной задаче, где необходимо менять и запоминать контрольную ячейку.
  Но подождите, а есть ли реальная причина почему, скажем, в среду он должен взять таблетку именно из ячейки СР?  На самом деле, нет. Конечно, алгоритм должен оставаться простым, иначе можно перегрузить даже долговременную память профессора. 
Можно допустить эту дополнительную свободу  при условии, что есть разумное правило для выбора ячейки, из которой нужно взять таблетку (а также для определения не была ли она уже взята).
  Как оказывается,  существует алгоритм, отвечающий всем требованиям профессора и допускающий только одно небольшое исключение из того, что таблетка всегда берётся из ячейки, соответствующей текущему дню недели. Профессор рассуждает следующим образом:
 
1.  Распределение таблеток по ячейкам коробочки должно оставаться достаточно равным, тогда, когда подойдёт время покупки новой упаковки, не останется много таблеток, чтобы с ними запутаться.
2. Необходимо избегать полностью равного распределения, иначе опять возникнет проблема с определением “контрольного контейнера”.
3. В силу (2), не всегда может быть правильным выбирать ячейку с наибольшим количеством таблеток.
  Учитывая эти условия, профессор приходит к идее, что в любой момент должно иметься не более трёх размеров ячеек, и что, если возможно, он должен брать таблетку из ячейки среднего размера. Чтобы сделать это как можно проще, предполагается только одна “куча” -- единственная ячейка, содержащая наибольшее число таблеток.  Обозначим k -- число таблеток в куче в любой день. Во всех остальных ячейках будет   или    таблеток,  и те ячейки, в которых  , будут непрерывной строкой справа от кучи. На рисунке ниже представлены различные  соответствующие конфигурации:




                                 Рис. Стр 115


 Первая ячейка справа от кучи, содержащая k-1 таблеток, будет той, из которой нужно взять таблетку. Если ячейки с  k-1 таблетками нет, тогда нужно взять таблетку из ячейки с кучей. В почти всех случаях надпись на ячейке, из которой берётся таблетка, правильная, то есть совпадает с текущим днём недели.
  Таким образом, например, коробочки на рисунке выше подготовлены для приёма таблетки во вторник, субботу, понедельник и четверг, соответственно.
  Исключением является момент, когда у профессора остаётся одна последняя таблетка. В предыдущий день он обнаружил две оставшиеся таблетки вместе в ячейке, помеченной соответствующим днём недели, и он одну оттуда взял (согласно правилу, что если нет ячейки размером на один меньше, чем куча, надо брать из кучи). Теперь последняя таблетка лежит в ячейке, помеченной вчерашним днём, и эту таблетку он принимает сегодня.
   Легко заметить, что если таблетки разложены должным образом, тогда их конфигурация сохраняет верность правилам  до последней таблетки. Но всегда ли возможно правильно настроить эту схему, когда приходят новые таблетки? Да, действительно, существует единственная правильная конфигурация для любого данного числа таблеток и любого данного утра дня недели. И эта та конфигурация, которую профессор создаёт, когда получает таблетки. Профессор просто вычисляет день, когда должна быть принята последняя таблетка (а именно, вчерашний день недели плюс число таблеток, modulo 7.
Предполагается, что сегодняшнюю  таблетку он ещё не выпил). Конечно, дни недели пронумерованы последовательно по modulo 7, но не имеет значения, который день номер 1. 
  Если, скажем, в среду утром пришло 32 таблетки, профессор знает, что последнюю таблетку надо будет принять в субботу (из ячейки ПТ!) Из этого следует, что ячейка ПТ содержит кучу. Профессор кладёт шесть таблеток в ПТ, по четыре таблетки в СБ, ВС, ПН, ВТ, и по пять в СР и ЧТ. И теперь у него всё устроено должным образом, чтобы принять таблетку для среды.
  Было бы уместно задать вопрос: “А что, если у нас меньше, чем семь ячеек? При каком наименьшем числе ячеек наша задача имеет решение? А что, если в неделе  дней, вместо семи,  каково тогда наименьшее возможное число ячеек, как функция от ?”
   Отметим, что профессорское решение работает и на Юпитере, где в неделе дней, и где коробочки для таблеток, конечно же, состоят из ячеек. В случае это сводится к тому, что в одной ячейке держится на одну или две таблетки больше.
  Решение для двух ячеек может быть использовано для любого чётного , так как человек, принимающий таблетки, знает, какой сейчас день этой чётной недели, и знает чётность этого дня. Так что две ячейки достаточны и, конечно, необходимы, когда -- чётное число.
  Однако, две ячейки не сработают, если -- нечётное число. Там непременно присутствуют два последовательных дня недели, которые должны будут сойтись к одинаковой одно-таблеточной конфигурации, так что, когда человек видит такую конфигурацию в первый из этих дней, он не может сказать, принял ли он таблетку в этот день или нет.
  Читателю, прошедшему уже такой долгий путь, не составит труда убедить себя, что  при нечётных  достаточно трёх ячеек. Но придумать простой алгоритм с тремя ячейками для семидневной недели довольно сложно. Следующая схема  мнемоническi использует двоичную запись.
  Пронумеруем дни недели, начиная с воскресенья = 1 и заканчивая субботой = 7, числами по modulo 7. Схема включает в себя семь “типов” конфигураций, обозначенных от 1 до 7, где образ каждого типа соответствует бинарному представлению его имени.
Ячейки располагаются линейно (“левая”, “центральная” и “правая”) и не рассматриваются, как циклические.
   Так, например, тип 1 = 011!2 требует, чтобы правая ячейка была задействована как куча с гораздо большим количеством таблеток, чем будет в каждой из двух остальных. Тип 3 = 011!2 требует, чтобы в левой  ячейке было существенно меньше таблеток, чем в любой из двух остальных ячеек, а тип 7 = 111!2 -- чтобы заполненность ячеек держалась почти на одном уровне.
  Точнее, типы 1, 2 и 4 имеют кучи (справа, в центре и слева, соответственно), в которых на две или три таблетки больше, чем в любой из остальных ячеек. Эти две другие ячейки, если различны, упорядочены так, что большая ячейка справа.
   Типы 3, 5 и 6 имеют oсобую наименьшую ячейку слева, в центре или справа, соответственно. Две другие ячейки содержат каждая на две таблетки больше, если они одинаковые. Если нет, они различаются по размеру не больше, чем на одну таблетку, большая ячейка расположена правее и содержит на 2 или 3 таблетки больше, чем самая маленькая.
  Тип 7 требует, чтобы содержимое ячеек отличалось друг от друга максимум на одну таблетку, с меньшими ячейками справа. (См. Таблицу ниже.)


   Стратегия теперь следующая: если в день получено таблеток, они распределяются согласно типу . Таблетки берутся так, чтобы сохранялся тип.
  В частности, каждый день, человек, принимающий таблетки, смотрит на тип  и поступает следующим образом: если он видит в день таблеток и , значит, он уже в этот день таблетку принял. В противном случае, он берёт таблетку из особой ячейки, в результате оставляя конфигурацию того же типа.
   
                                       Таблица 1 стр 118


  Когда остаётся три или меньше таблетки, становится трудно следовать какому-либо типу, но можно воспользоваться  правилом “слева-направо” для типов, чтобы решать, как необходимо менять дальше конфигурации. Это сводится к использованию следующей таблицы:


                                     Таблица 2 стр 118.


   Чтобы воспользоваться таблицей, нужно найти в ней запись, соответствующую  и . Если такая имеется, нужно взять таблетку так, чтобы после получилась конфигурация ниже и направо (следуя по диагонали). В противном случае, конфигурация будет соответствовать , и, значит,  таблетку в этот день уже приняли.
